### 网络



#### 一、TCP 和 UDP 差别

1、基于连接与无连接；

2、对系统资源的要求（TCP较多，UDP少）；

3、UDP程序结构较简单；

4、流模式与数据报模式 ；

5、TCP保证数据正确性，UDP可能丢包；

6、TCP保证数据顺序，UDP不保证。

##### 1、UDP

- 结构
  - 源端口： 发送方端口
  - 目的端口： 目的端口
  - 报文长度 ：整个UDP报文长度
  - 校验和
  - 数据

##### 2、TCP

- 结构
  - 源端口号（16位）
  - 目的端口号（16位）
  - 序号（32位 **seq**）
  - 确认序号 ack （32位 **seq+1**）
  - 数据偏移
  - 窗口大小
  - 校验和
  - 紧急指针
  - 选项
    - 长度可变，最长可达40个字节。当没有使用“选项”时，TCP的首部长度是20字节。

- 三次握手

  1. 客户端发送一个带SYN标志的TCP报文（报文1）到服务器端，表示希望建立一个TCP连接。
  2. 服务器发送一个带ACK标志和SYN标志的TCP报文（报文2）给客户端，ACK用于对报文1的回应，SYN用于询问客户端是否准备好进行数据传输。
  3. 客户端发送一个带ACK标志的TCP报文（报文3），作为报文2的回应

- 四次挥手

   由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。原则是主动关闭的一方（如已传输完所有数据等原因）发送一个FIN报文来表示终止这个方向的连接，收到一个FIN意味着这个方向不再有数据流动，但另一个方向仍能继续发送数据，直到另一个方向也发送FIN报文。四次挥手的具体过程如下：

  1. 客户端发送一个FIN报文（报文4）给服务器，表示我将关闭客户端到服务器端这个方向的连接。
  2. 服务器收到报文4后，发送一个ACK报文（报文5）给客户端，序号为报文4的序号加1。
  3. 服务器发送一个FIN报文（报文6）给客户端，表示自己也将关闭服务器端到客户端这个方向的连接。
  4. 客户端收到报文6后，发回一个ACK报文（报文7）给服务器，序号为报文6的序号加1。

- 重传机制

- 滑动窗口
  - 无需等待确认应答，而可以继续发送数据的最大值。
  - 窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。
  
- 流量控制
  
  TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。
  
  - **由滑动窗口协议（连续ARQ协议）实现**。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。
  
  - 流量控制引发的死锁
  
    为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小
  
- 拥塞控制
  - **拥塞窗口 cwnd**是发送方维护的一个的状态变量，它会根据**网络的拥塞程度动态变化的**。
  
  - **慢启动**
  
     cwnd从1开始，每次为上次两倍
  
  - **拥塞避免**
  
    拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1
  
  - 拥塞发生
  
    网络出现超时（拥塞），则更新后的慢启动上限为之前一半，cwnd重新设置为1，并执行慢开始算法。当cwnd达上限时，改为执行拥塞避免算法
  
  - **快重传算法**
  
    快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）
  
  - **快恢复**
  
    当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把当前的cwnp减半赋值给ssthresh，然后执行拥塞避免算法。

- **TCP 连接状态（11种）**

  - **CLOSED**：初始状态，表示TCP连接是“关闭着的”或“未打开的”。

  - **LISTEN** ：表示服务器端的某个SOCKET处于监听状态，可以接受客户端的连接。
  - **SYN_RCVD** ：表示接收到了SYN报文。在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat很难看到这种状态，除非故意写一个监测程序，将三次TCP握手过程中最后一个ACK报文不予发送。当TCP连接处于此状态时，再收到客户端的ACK报文，它就会进入到ESTABLISHED 状态。

  - **SYN_SENT** ：这个状态与SYN_RCVD 状态相呼应，当客户端SOCKET执行connect()进行连接时，它首先发送SYN报文，然后随即进入到SYN_SENT 状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT 状态表示客户端已发送SYN报文。

  - **ESTABLISHED** ：表示TCP连接已经成功建立。

  - **FIN_WAIT_1** ：这个状态得好好解释一下，其实FIN_WAIT_1 和FIN_WAIT_2 两种状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET进入到FIN_WAIT_1 状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2 状态。当然在实际的正常情况下，无论对方处于任何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1 状态一般是比较难见到的，而FIN_WAIT_2 状态有时仍可以用netstat看到。

  - **FIN_WAIT_2** ：上面已经解释了这种状态的由来，实际上FIN_WAIT_2状态下的SOCKET表示半连接，即有一方调用close()主动要求关闭连接。注意：FIN_WAIT_2 是没有超时的（不像TIME_WAIT 状态），这种状态下如果对方不关闭（不配合完成4次挥手过程），那这个 FIN_WAIT_2 状态将一直保持到系统重启，越来越多的FIN_WAIT_2 状态会导致内核crash。

  - **TIME_WAIT** ：表示收到了对方的FIN报文，并发送出了ACK报文。 TIME_WAIT状态下的TCP连接会等待2*MSL（Max Segment Lifetime，最大分段生存期，指一个TCP报文在Internet上的最长生存时间。每个具体的TCP协议实现都必须选择一个确定的MSL值，RFC 1122建议是2分钟，但BSD传统实现采用了30秒，Linux可以cat /proc/sys/net/ipv4/tcp_fin_timeout看到本机的这个值），然后即可回到CLOSED 可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。

  - **CLOSING** ：这种状态在实际情况中应该很少见，属于一种比较罕见的例外状态。正常情况下，当一方发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING 状态表示一方发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？那就是当双方几乎在同时close()一个SOCKET的话，**就出现了双方同时发送FIN报文的情况**，这是就会出现CLOSING 状态，表示双方都正在关闭SOCKET连接。

  - **CLOSE_WAIT** ：表示正在等待关闭。怎么理解呢？当对方close()一个SOCKET后发送FIN报文给自己，你的系统毫无疑问地将会回应一个ACK报文给对方，此时TCP连接则进入到CLOSE_WAIT状态。接下来呢，你需要检查自己是否还有数据要发送给对方，如果没有的话，那你也就可以close()这个SOCKET并发送FIN报文给对方，即关闭自己到对方这个方向的连接。有数据的话则看程序的策略，继续发送或丢弃。简单地说，当你处于CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。

  - **LAST_ACK** ：当被动关闭的一方在发送FIN报文后，等待对方的ACK报文的时候，就处于LAST_ACK 状态。当收到对方的ACK报文后，也就可以进入到CLOSED 可用状态了。

  - **为什么有time_wait？**
    - 防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到；
    - 保证 TCP 连接的远程被正确关闭，即等待被动关闭连接的一方收到 `FIN` 对应的 `ACK` 消息；

##### 3、IP

​	网络层，Ip数据报

- 版本

- 首部长度

  - 固定长度部分20字节，可变部分长度40字节

- 服务类型

- 总长度

- 标识

- 标志

- 片偏移

- 生存时间

- 协议

  tcp、udp

- 首部校验和

- 源ip地址

- 目的ip地址

#### 二、http1 和http2 的区别

##### 1、http请求结构

- **请求行**

  - 请求方法-空格-url-空格-协议版本-回车符-换行符

- **请求头部**

  - 头部字段名-冒号-值-回车符-换行符
  - host （目的主机域名）user-agent（客户端信息）

- **空行**

  请求头后面必须有一个空行

- **请求数据**

  请求的数据也叫请求体，可以添加任意的其它数据。

- **response**
  - 状态行
  - 响应头
  - 空行
  - 相应体

##### 2、区别

- **多路复用**

  多路复用允许单一的 HTTP/2 连接同时发起多重的请求-响应消息。

- **数据压缩**

​	   HTTP2.0使用HPACK[算法](http://lib.csdn.net/base/datastructure)对header的数据进行压缩

- **服务器推送**

  我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。

##### 3、tls/ssl加密原理

- 1、客户端请求 HTTPS 网址，然后连接到 server 的 443 端口
- 2、采用 HTTPS 协议的服务器必须要有一套数字证书（私钥（非对称加密）和公钥（对称加密））
- 3.服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。
- 4.客户端解析证书并对其进行验证。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密。
- 5.客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥。
- 6.服务器在收到随机码 KEY 之后会使用私钥B将其解密。
- 7.服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。
- 8.双方使用对称加密愉快地传输所有数据。

#### 三、websocket

websocket 是有http协议升级请求到websocket

特别这个请求需要添加两项额外的header：

- **Connection: Upgrade**

  设置 `Connection` 头的值为 `"Upgrade"` 来指示这是一个升级请求.

- **Upgrade: protocols**

  `Upgrade` 头指定一项或多项协议名，按优先级排序，以逗号分隔。

#### 四、OSI 七层模型

##### 7、应用层 （TCP/IP 应用层）

TFTP、HTTP、SNMP、FTP、SMTP、DNS、Telnet

##### 6、表示层（TCP/IP 应用层）

没有协议

##### 5、会话层（TCP/IP 应用层）

没有协议

##### 4、传输层（TCP/IP 传输层）

TCP、UDP

##### 3、网路层（TCP/IP 网络层）

**IP**、**ICMP**（**ping**）、RIP、OSPF、BGP、

##### 2、数据链路层（TCP/IP 链路层）

SLIP、CSLIP、PPP、ARP、RARP、MTU

##### 1、物理层（TCP/IP 链路层）

ISO2110、IEEE802、IEEE802.2