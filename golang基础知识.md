### golang 基础知识

#### 一、GPM 模型

- **G(goroutine) 协程**

  - 初始分配2KB内存，OS线程固定分配2M内存
  - 每个goroutine对应一个G结构体，G存储goroutine的运行堆栈、状态以及任务函数
  - 

- **P(Processor) 处理器调度器**

  对G相当于CPU核，G只有绑定到P才能被调度

  - 每个P维护一个G的本地队列

- **M(Machine) 线程**
  - GOMAXPROCS控制数量，默认情况跟内核数相同；每个线程分配到一个CPU上就不至于出现线程的上下文切换，可以降低开销

- **调度过程**

  - 当通过go关键字创建一个新的goroutine时，它会优先被放入P的本地队列。M绑定一个P，接着会启动一个OS线程，循环从P的本地队列里取出一个goroutine并执行。如果P本地队列没有了，会尝试从global队列里寻找G来执行，如果还为空，会随机挑选另外一个P，从它的本地队列中拿走一半的G到自己的队列中执行。

- **阻塞**

  go runtime 会在下面的goroutine被阻塞的情况下运行另外一个goroutine

  - blocking syscall（阻塞系统调用,例打开一个文件）

  - network input （网络输入）

  - channel operations （管道操作）

  - primitives in the sync package

    **归类于两种情况**

  - **用户态阻塞/唤醒**

    当goroutine因为channel 操作阻塞时，对应的G会被放置到wait队列，G状态变为—Gwaiting，当G被另一端G2唤醒时，G被标记为runnable，尝试加入G2所在P的runnext,然后再是P的local队列和Global队列。

  - **系统调用阻塞**

    当G被阻塞在某个系统调用上时，此时 G 会阻塞在 `_Gsyscall` 状态，M 也处于 block on syscall 状态，此时的 M 可被抢占调度：执行该 G 的 M 会与 P 解绑，而 P 则尝试与其它空闲的 M 绑定，继续执行其它 G。如果没有其它空闲的 M，但 P 的 Local 队列中仍然有 G 需要执行，则创建一个新的 M；当系统调用完成后，G 会重新尝试获取一个空闲的 P 进入它的 Local 队列恢复执行，如果没有空闲的 P，G 会被标记为 runnable 加入到 Global 队列。

#### 二、垃圾回收机制

- **标记-清除 ：三色标记算法**

  - 起初所有对象都是白色。
  - 从根出发扫描所有可达对象，标记为灰色，放入待处理队列。
  - 从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。
  - 重复 3，直到灰色对象队列为空。此时白色对象即为垃圾，进行回收。

- 混合写屏障

  - `GC`开始时将栈上所有对象标记为黑色，无须`STW`
  - `GC`期间在栈上创建的新对象均标记为黑色
  - 将被删除的下游对象标记为灰色
  - 将被添加的下游对象标记为灰色

- **触发时机**

  - 堆内存的大小达到一定阈值
  - 距离上一次垃圾回收超过一定阈值时
  - 如果当前没有启动GC则开始新一轮的GC

- **Golang GC四个阶段**

  - 清除终止`Sweep Termination`：

  - - 暂停程序
    - 清扫未被回收的内存管理单元span，当上一轮GC的清扫工作完成后才可以开始新一轮的GC

  - 标记`Mark`：

  - - 切换至`_GCmark`，开启写屏障和用户程序协助`Mutator Assiste`并将根对象添加到三色标记法队列
    - 恢复程序，标记进程和`Mutator Assiste`进程会开始并发标记内存中的对象，混合写屏障将被删除的指针和新加入的指针都标记成灰色，新创建的对象标记成黑色
    - 扫描根对象（包括所有goroutine的栈、全局对象以及不在堆中的运行时数据结构），扫描goroutine栈期间会暂停当前处理器
    - 依次处理三色标记法队列，将扫描过的对象标记为黑色并将它们指向的对象标记成灰色
    - 使用分布式终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段

  - 标记终止`Mark Termination`

  - - 暂停程序，切换至`_GCmarktermination`并关闭辅助标记的用户程序
    - 清理处理器上的线程缓存

  - 清除`Sweep`

  - - 将状态切换至`_GCoff`，关闭混合写屏障
    - 恢复用户程序，所有新创建的对象标记为白色
    - 后台并发清理所有的内存管理单元span，当goroutine申请新的内存管理单元时就会触发清理


#### 三、内存模型，内存逃逸

##### 1、内存分配

 Golang 程序在启动时，会向操作系统申请一定区域的内存，分为栈（Stack）和堆（Heap）。栈内存会随着函数的调用分配和回收；堆内存由程序申请分配，由垃圾回收器（Garbage Collector）负责回收。性能上，栈内存的使用和回收更迅速一些；尽管Golang 的 GC 很高效，但也不可避免的会带来一些性能损耗。因此，Go 优先使用栈内存进行内存分配。在不得不将对象分配到堆上时，才将特定的对象放到堆中。

##### 2、内存逃逸

**golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。编译期间如果变量通过了这些校验，它就可以在栈上分配。否则就说它逃逸 了，必须在堆上分配。**

- 1、堆上动态分配内存比栈上静态分配内存，开销大很多。
- 2、变量分配在栈上需要能在编译期确定它的作用域，否则会分配到堆上。
- 3、Go编译器会在编译期对考察变量的作用域，并作一系列检查，如果它的作用域在运行期间对编译器一直是可知的，那么就会分配到栈上。简单来说，编译器会根据变量是否被外部引用来决定是否逃逸。
- 4、对于Go程序员来说，编译器的这些逃逸分析规则不需要掌握，我们只需通过go build -gcflags '-m’命令来观察变量逃逸情况就行了。
- 5、不要盲目使用变量的指针作为函数参数，虽然它会减少复制操作。但其实当参数为变量自身的时候，复制是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内存少的多。
- 6、逃逸分析在编译阶段完成的。

**引起变量逃逸的情况：**

- **在方法内把局部变量指针返回** 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。
- **发送指针或带有指针的值到 channel 中。** 在编译时，是没有办法知道哪个 `goroutine` 会在 `channel` 上接收数据。所以编译器没法知道变量什么时候才会被释放
- **在一个切片上存储指针或带指针的值。** 一个典型的例子就是 `[]*string` 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
- **slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。** slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
- **在 interface 类型上调用方法。** 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。

#### 四、基础数据结构

##### 1、数组与切片

- 数组是值类型，负值和参数都会对数组进行拷贝
- slice 是一个不定长的，总是指向底层数组的数据结构
- **切片扩容**
  - 一个切片无法容纳更多的元素，Go 语言就会想办法扩容。但它并不会改变原来的切片，而
    是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中。新扩容的容量是原来的2倍或者1.5 倍

##### 2、map

`map`的底层实现是一个散列表

- map的key需要能确定唯一，可以用==号判断
  - 支持：bool、数字、string、指针、channel、还有只包含前面几个类型的 interface types, structs, arrays 
  - 不支持：slice、map、function

- hash
  - 均匀性
  - 效率高
  - 可确定性
- hash冲突解决
  - 链地址法
- **扩容机制**
  - 扩容时机
    - 装载因子达到临界值 - **翻倍扩容**
    - 判断溢出桶是否太多 - **等量扩容**
  - **bucket搬迁**
    - 扩容是渐进试的，扩容的时候并没有将旧桶数据转移到新桶。数据转移遵循了写时复制(copy on write)的规则。
- 是否线程安全

##### 3、channel

- **循环缓冲链表**
- **sendx/recvx** 用于记录`buf`这个循环链表中的index
- **互斥锁**
- **recvq/sendq **  goroutine抽象队列，是个双向链表